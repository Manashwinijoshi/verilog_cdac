default value of net/wire => z
integer default value = x;

integer stores signed
reg stores unsigned, but can be declared as signed 

realnumber constants and real registers -can be specifiedin scientifc and decimal notation

delta=4e10;-scientific 
delta=2.14;- decimal

integer i;

i=delta; then the value will be rounded off to nearest value 

time x;- atleast 64bt width,but dependson the implementation
initial 
  x=$time;

vectors,arrays
reg [7:0]a[0:4];
integer a[3:0][6:0];
reg [4:0] a1 [3:0][6:0];

parameters- used to define the constants 
localparameters - cant be changed - the state encoding for a state machine can be defined using localparam
whereas the parameters can be changed while the module instantiation or using defparam


Strings in Verilog are purely for simulation-time convenience, not for actual synthesized hardware.
reg [8*11:1]str; str of 11 byteswide

system tasks:

$<keyword>

$display(); - similar to the printf - inserts new line at the end
$display without the arguments produces a newline
'
%d or %D
%b or %B
%s OR %S
%h or %H - hex
%c or %C ascii character
%m or %M - hierarchical name
%v or %V display strength
%o or %O
%e or %E display realnumber in scientfic format
%f in decimal
%g or %G display real number in scientific or decimal whichever is shorter


$monitor - verilog provides a mechanism to monitor a signal when its value changes 
it continously monitors the values of the variables or signals specified in the parameter list and displays all parameters
in the list whenever the value of any one variable or signal changes 

only one monitorng list can be active at a time ,if there are more than one $monitor in your simulation then the last $monitor will be the active statement 

two tasks are used one is monitoron- enable
and other one is monitoroff-disable

$stop-> stop the simulation
it puts the design in the interactive mode
designer can stop and start debugging
it is used when designer wants to suspend the simulation and examine the values of signals in the design

$finish;

this terminates the simulation

// delays

in the assign -> continous assignments
it controls the time between the change in right hand side operand and when the new value is assigned to the left hand side

3 ways

1-> regular assignment delay

assign #10 out=in1&in2;

basically my left hand side in2&in1 the whole expression will be computed after 10 ns , 
so if i change these inputs the in between 10 ns , then the output of this is lost 

example at 80 i change my in1 0 to 1 (in2=0)
and at 85 i change my in1 1 to 0 again (in2=0)

now as after 10 ns my computation happens
in1 value will be 0 and the in2 is 0 so the output is 1 


operations::


we have manyy different operators
lets start with the arithmetic operators
* - + / % **

now if any of the input as x as its one of the bit , then he result will be x 
example in1=3'b10x
in2=3'b000;

then my sum=in1+in2;
will be 3'bxxx;

unary operators:

be careful while using the '-' operator 

see we use it to represent the negative numbers 

example : integer sum= -10/5;

never do : -'d10/5 => is equivalent to the 2's complement of the 'd10 / 5
// hence an incorrect answer 

so dont use - <size>'<base><number>
if you are dealing with the negative numbers while operations

----------------------------------------------------------------

logical operators

&& || ! 
these evaluate to 1 or 0 or x

remember if any operand bit x or z , it is equivalent to x , and is normally treated by simulators as a false condition

relational operators

> < >= <=

it returns 0 or 1
if if there are any unknown x or z bits in the operands then the expression takes the value of the x 

z=3'b10x;
x=3'b100;

z<x will evaluate to x

equality operators

== != === !==

a==b , will give 0 or 1 or if any bit in it as x or z the result will be x
a!=b same as the above

a===b compares both operans bit by bit , including x or z , results in 1 if the operands match exactly , including x and z , 0 if not . it will never yield in x 

bitwise operators
~, & , | , ^ , ^~ 

conditional operator 
(conditional expr)?true_expression:false_expression

if true-> true expression
false -> false expression

now if the result is x , then both true and false expressions are evaluated and their reults are compared , bit by bit , to return for eacch bit 
an x if the bits are different and the value of the bits if they are the same 

example: assign res=sel?4'b1101:4'b0111;

if my sel is x;

then my res is 4'bx1x1;
---------------------------------------
strcutured procedures : 

always, initial-> each flow starts at the simulation time 0

they cant be nested 

initial -> only once execution

always=> repeated continuously 
example -> clock generation

inside these blocks we use procedural assignments 

the value placed on a varaible will remain unchanged until another procedural assignment updated the variable with a different value 

the left side of the expression can be reg or integer or real or time, "NO WIRE"

there are two tytpes -> blocking and non blocking

blocking -> in a specified order
non blocking->they dont block the execution of the other statements , 
after blocking assignment typically , non blocking are executed last in the time step 

be aware of the race conditions

always@(posedge clk)
  a=b;

always@(posedge clk)
   b=a;

here it depends on the simulator , which statement will be executed first 
so swapping will not occur
either both will have a or b values (same values in a and b )

but the same with the non blocking gives us different story 
always@(posedge clk)
  a<=b;

always@(posedge clk)
   b<=a;

the values will be swapped , now this is because firstly at the simulation , they both are evalauted and are stored in some temparory thingy 
then at the end of the time step they are assigned to the r_side 

event in the verilog 

event demo_event; // define

->demo_event   // triggering 

always@(demo_event)//awaits for trigger and then after trigger 
   //statements 

















