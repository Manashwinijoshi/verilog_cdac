default value of net/wire => z
integer default value = x;

integer stores signed
reg stores unsigned, but can be declared as signed 

realnumber constants and real registers -can be specifiedin scientifc and decimal notation

delta=4e10;-scientific 
delta=2.14;- decimal

integer i;

i=delta; then the value will be rounded off to nearest value 

time x;- atleast 64bt width,but dependson the implementation
initial 
  x=$time;

vectors,arrays
reg [7:0]a[0:4];
integer a[3:0][6:0];
reg [4:0] a1 [3:0][6:0];

parameters- used to define the constants 
localparameters - cant be changed - the state encoding for a state machine can be defined using localparam
whereas the parameters can be changed while the module instantiation or using defparam


Strings in Verilog are purely for simulation-time convenience, not for actual synthesized hardware.
reg [8*11:1]str; str of 11 byteswide

system tasks:

$<keyword>

$display(); - similar to the printf - inserts new line at the end
$display without the arguments produces a newline
'
%d or %D
%b or %B
%s OR %S
%h or %H - hex
%c or %C ascii character
%m or %M - hierarchical name
%v or %V display strength
%o or %O
%e or %E display realnumber in scientfic format
%f in decimal
%g or %G display real number in scientific or decimal whichever is shorter


$monitor - verilog provides a mechanism to monitor a signal when its value changes 
it continously monitors the values of the variables or signals specified in the parameter list and displays all parameters
in the list whenever the value of any one variable or signal changes 

only one monitorng list can be active at a time ,if there are more than one $monitor in your simulation then the last $monitor will be the active statement 

two tasks are used one is monitoron- enable
and other one is monitoroff-disable

$stop-> stop the simulation
it puts the design in the interactive mode
designer can stop and start debugging
it is used when designer wants to suspend the simulation and examine the values of signals in the design

$finish;

this terminates the simulation

// delays

in the assign -> continous assignments
it controls the time between the change in right hand side operand and when the new value is assigned to the left hand side

3 ways

1-> regular assignment delay

assign #10 out=in1&in2;

basically my left hand side in2&in1 the whole expression will be computed after 10 ns , 
so if i change these inputs the in between 10 ns , then the output of this is lost 

example at 80 i change my in1 0 to 1 (in2=0)
and at 85 i change my in1 1 to 0 again (in2=0)

now as after 10 ns my computation happens
in1 value will be 0 and the in2 is 0 so the output is 1 


operations::


we have manyy different operators
lets start with the arithmetic operators
* - + / % **

now if any of the input as x as its one of the bit , then he result will be x 
example in1=3'b10x
in2=3'b000;

then my sum=in1+in2;
will be 3'bxxx;

unary operators:

be careful while using the '-' operator 

see we use it to represent the negative numbers 

example : integer sum= -10/5;

never do : -'d10/5 => is equivalent to the 2's complement of the 'd10 / 5
// hence an incorrect answer 

so dont use - <size>'<base><number>
if you are dealing with the negative numbers while operations

----------------------------------------------------------------

logical operators

&& || ! 
these evaluate to 1 or 0 or x

remember if any operand bit x or z , it is equivalent to x , and is normally treated by simulators as a false condition

relational operators

> < >= <=

it returns 0 or 1
if if there are any unknown x or z bits in the operands then the expression takes the value of the x 

z=3'b10x;
x=3'b100;

z<x will evaluate to x

equality operators

== != === !==

a==b , will give 0 or 1 or if any bit in it as x or z the result will be x
a!=b same as the above

a===b compares both operans bit by bit , including x or z , results in 1 if the operands match exactly , including x and z , 0 if not . it will never yield in x 

bitwise operators
~, & , | , ^ , ^~ 















